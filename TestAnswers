1) Какова разница между абстрактным классом и интерфейсом? 
	
	Абстрактный класс - это обычный класс, но в котором есть абстрактный метод(ы) - метод(ы), не имеющие тела.
	.	Как класс, так и метод объявляются абстрактыми с помощью добавления ключевого слова abstract в сигнатуру:
	.	public abstract class SomeClass {
	.	  public abstract void method1();
	.	  public void method2();
	.	}
	.	Нельзя создать экземпляр абстрактного класса, так как его поведение частично или полностью не реализовано. Абстрактные методы могут пригодится в классах-предках, при написании которых конкретная реализация еще не имеет значения.
	.	Тогда реализацию этих методов можно переложить на потомков. Либо снова сделать метод абстрактным и передать реализацию дальше по цепочке наследования.
	.	Поэтому нельзя сделать абстрактный класс final.
	.	
	.	Интерфейсы нужны для добавления классам функциональности, которой нет среди предков этого класса.
	.	Интерфейс задает “контракт” по набору методов, которые должны быть реализованы в классах, использующие этот интерфейс.
	.	Класс может реализовывать несколько интерфейсов одновременно. Либо интерфейс может наследоваться от нескольких интерфейсов сразу. 
	.	Нельзя создать экземпляр интерфейса.
	.	
	.	Содержимое интерфейса сильно ограничено. В нем могут быть:
	.	- методы (по умолчанию они public static - это можно не писать в сигнатуру методов) - а в абстрактном классе методы могут иметь разные модификаторы доступа
	.	- константные поля (по умолчанию они public static final - это также можно не писать при объявлении полей) (для полей должны быть заданы значения) 
	.	public interface I1 {
	.	void method1(); // = public static void method1();
	.	}
	.	
	.	public interface I2 {
	.	void method2(); 
	.	int X = 1; // = public static final X = 1;
	.	}
	.	
	.	Далее можно сделать так:
	.	public class C1 implements I1, I2 {
	.	}

	.	Или так:
	.	public interface I3 extends I1, I2 {
	.	}
	.	public class C1 implements I3 {
	.	}
	.	
	.	В результате класс C1 должен будет реализовать методы method1 и method2.
	.	Либо, объявить эти методы (или один из них) и себя абстрактными и передать реализацию наследникам.
	.	
	.	Также есть интерфейсы-метки, которые не имеют никаких методов.
	.	Например, Clonable и Serialazible.
	.	Их имплементация означает, что объект соответствующего класса может быть клонирован или сериализован.  
	
2) Как «насильно» вызвать сборку мусора? 
	
	Сборка мусора (garbage collection) - это освобождение памяти из-под объектов, на которые уже нет ссылок, в куче (heap).
	.	Вообще, память в Java делится на два типа - heap и stack.
	.	
	.	Сборку мусора вызвать нельзя, можно лишь “заказать” несколькими способами:
	.	- System.gc()
	.	- Runtime.getRuntime().gc()
	.	- с помощью jvisualvm
	.	Через неопределенный срок после запроса сборщик мусора выполнит сборку.
	.	
	.	Основная проблема - сборка мусора может быть ресурсоемкой. Если она начнется в “неудобный” момент (например, во время тяжелых вычислений), то производительность программы упадет.
	
	3) Когда требуется явное приведение классов?
	
	Class cast:
	.	
	.	- implicit (неявное)
	.	Если класс наследника приводится к классу предка.
	.	Также называется восходящим приведением.
	.	Реализует принцип полиморфизма и механизм позднего связывания - когда реальный класс объекта будет известен только на этапе выполнения.
	.	Полиморфизм - принцип ООП, согласно которому переменная одного и того же типа может ссылаться на объекты различных классов.

	.	- explicit (явное)
	.	Если класс предка приводится к классу наследника.
	.	Также называется нисходящим приведением.
	.	Реализует механизм раннего связывания
	.	Если явное приведение не сработает, то будет вброшено непроверяемое исключение ClassCastException.
	.	
	.	String str = “some string”;
	.	Object obj = str; // implicit cast String str2 = (String) obj; // explicit cast
	.	((String) obj).length; // explisit cast
	
	4) Чем конструкторы отличаются от других методов? 
	
	Конструктор используется для создания новых объектов соответствующего класса (класса, где этот конструктор реализован).
	.	У конструктора нет возвращаемого значения и типа возвращаемого значения в его сигнатуре. Имя конструктора должно совпадать с именем класса, в котором он реализован. Конструкторы нельзя переопределять (@Overrride), но можно использовать конструкторы из текущего класса и классов-предков.
	.	Если при вызове конструктора произойдет исключение, то объект создан не будет.
	.	Конструктор нельзя сделать abstract или final.
	
5)	Можно ли вызывать конструкторы один из другого, если их в классе несколько?
	
	Да, используя ключевое слово this.
	.	Например:
	.	- this() - this(param1, param2)
	.	При этом вызов конструктора должен идти первой строкой
	
	6) В чем разница между JDK и JRE? 
	
	JRE - Java Runtime Environment - Cреда выполнения.
	.	Включает в себя виртуальную машину Java (JVM) и надо стандартных библиотек.
	.	JVM интерпретирует предварительно скомпилированный байт-код.
	.	
	.	JDK - Java Development Kit - Средства разработки.
	.	Содержит дополнительно исходные коды стандартных библиотек с примерами использования, а также набор утилит для разработчика:
	.	- javac - для компиляции исходного кода в байт-код
	.	- jmap - для работы с памятью
	.	- jstack - для получения информации о 
	.	- jconsole
	.	- jvisualvm - графическая утилита для мониторинга выполнения программ
	
	7) Имеет ли значение в каком порядке перехватывать исключения FileNotFoundException и IOExceptipon?
	
	Исключительная ситуация - некое аварийное состояние, произошедшее во время выполнения программного кода, после которого программа не может продолжать свое выполнение в обычном режиме.
	.	Исключение - это объект, описывающий эту ситуацию. Он создается и вбрасывается в метод при наступлении аварийного состояния. Исключения бывают обрабатываемые (их нужно обрабатывать на уровне кода) и необрабатываемые (поток, в котором они возникают, прекращает свою работу).
	.	Обработать исключение можно непосредственно в методе, в который оно было вброшено с помощью try-catch, либо передать его методу выше, используя в сигнатуре метода ключевое слово throws.
	.	
	.	Так как исключение FileNotFoundException является наследником IOException, то порядок их обработки важен.
	.	
	.	Правильно написать так:
	.	try {
	.	// something
	.	} catch (FileNotFoundException e1) {
	.	// handle e1
	.	} catch (IOException e2) {
	.	// handle e2
	.	}
	.	
	.	Если написать так, то блок обработки FileNotFoundException никогда не будет достигнут: try {
	.	// something
	.	} catch (IOException e1) {
	.	// handle e1
	.	} catch (FileNotFoundException e2) {
	.	// handle e2
	.	}
	.	
	.	А если бы два исключения не были бы связаны через наследование, то порядок был бы не важен.
	
	8)	Могут ли внутренние классы, описанные внутри метода, иметь доступ к локальным переменным этого метода?
	
	Такой тип внутреннего класса называется локальный.
	.	Можно, передавая копии на ссылки этих переменных внутрь класса.
	
	9) Как подкласс может обратиться к методу или конструктору из суперкласса?
	
	super.method() - обращение к методу суперкласса (метод должен иметь модификатор видимости public или protected, либо default если классы расположены в одном пакете).
	.	super() - обращение к конструктору суперкласса (модификатор доступа по тем же правилам, что и для методов).
	При этом вызов конструктора суперкласса должен идти первой строкой в конструкторе наследника.
	
	10) В чем разница между очередью и стеком?
	
	Очередь реализует модель FIFO (First In First Out) - элементы извлекаются из коллекции в том же порядке, в котором они туда складывались. Обычно используется для хранения объектов перед их последовательной обработкой.
	.	В Java описывается интерфейсом Queue. Его основные методы:
	.	- offer(item) - внести элемент в конец очереди
	.	- poll() - извлечь элемент из начала очереди
	.	 Стек реализует модель LIFO (Last In First Out) - первым извлекается элемент, внесенный в коллекцию последним. Можно представить в виде стопки элементов. В Java реализуется классом Stack. Его основные методы:
	.	- push(item) - положить верхний элемент в стопку
	.	- peek() - посмотреть верхний элемент в стопке (но не извлекать его)
	.	- pop() - взять верхний элемент из стопки
	
	11) Что вам приходит в голову, когда вы слышите о новом поколении (young generation) в Java?
	
	Ничего :) Но я почитаю об этом.
	
	12) Есть два класса: A и B. Класс B должен информировать класс A когда случается некое важное событие. Какой design-pattern вы должны реализовать?
	
	Наблюдатель (Observer).
	
	13) Какой модификатор доступа надо указать в классе, чтобы доступ к нему имели только классы из того же пакета?
	
	Модификаторы доступа:
	.	- public - доступ есть у всех, независимо от пакета
	.	- private - доступа нет ни у кого
	.	- protected - доступ есть только у наследников
	.	- default (модификатор не указан) - доступ есть у всех классов того же пакета
	.	
	.	Ответ - default.
	
	14) Чем отличается статический внутренний класс от просто внутреннего класса?
	
	1) Статический внутренний класс принадлежит классу.
	.	2) Внутренной класс принадлежит объектам класса.
	.	То есть, внутри статического внутреннего класса нет this.
	.	Состояние статического внутреннего класса одинаково для всех экземпляров внешнего класса.
	
	15) можно ли обратиться к не-статической переменной из статического метода?
	
	Можно, но нужно передать объект внешнего класса (содержащий эту переменную) либо сразу ссылку на саму переменную внутрь статического метода в качестве параметра. 
	.	public class A {
	.	  public x;
	.	  public static void method(A a) {
	.	    a.x = ..
	.	  }
	.	}
	.	
	.	..
	.	A a = new A();
	.	A.method(a);
	.	.. 
	
16) какие типы данных есть в Java?

1) Примитивные:
	.	- целочисленные (byte, int, short, long)
	.	- вещественные (float, double)
	.	- символьный (char)
	.	- логический (boolean)
	.	2) Ссылочные:
	.	- классы
	.	- массивы
	.	- перечисления 
	.	Для примитивных типов существуют обертки (wrappers), которые оборачивают значение в объект.
	.	Также при использовании оберток работают механизмы автоупаковки/распаковки.
	.	..
	.	Integer i1 = 12; // автоупаковка
	.	int int1 = 13;
	.	Integer i2 = int1; // автоупаковка
	.	i2++; // автораспаковка - инкремент - автоупаковка

17) Чем отличаются переопределение (Override) и перегрузка (Overload)

Перегрузка - это наличие в классе нескольких методов с одним названием, но разной сигнатурой.
	.	Сигнатура включает в себя (помимо названия) тип возвращаемого значения и типы/количество параметров. Названия параметров значения не играют.
	.	Например:
	.	public class C1 {
	.	public int get(int a, int b) {..}
	.	public float get(float a, float b) {..}
	.	public int get(int a, int b, inc c) {..}
	.	public int get(int c, int d) {..} // ошибка, так как сигнатура совпадает с первым методом
	.	}

	.	Переопределение - это изменение метода класса наследниками этого класса.
	.	
	.	Например:
	.	public class Parent {
	.	public void method() {
	.	}
	.	}
	.	
	.	public class Child extends Parent {
	.	@Override
	.	public void method() {
	.	  // тут наследник может либо полностью переопределять поведение, либо сначала выполнить метод предка super.method(), а потом добавить свою логику
	.	  // или даже запретить использование этого метода, выбрасывая в нем исключение (IllegalOperationException или что-то вроде того)
	.	}
	.	}
	.	
	.	Если указать аннотацию @Override и при этом в предках класса не будет предопределяемого метода, то компилятор выдаст ошибку.
	.	То есть, это хороший способ контроля при переопределении
	
	18) Что такое итератор?
	
	Итератор - это объект, предназначенный для перебора и удаления элементов коллекции.
	.	Коллекция - это объект, содержащий внутри себя набор однотипных объектов, и имеющий встроенные методы для работы с этими элементами (добавление, модификация, удаление, поиск и т.д.). 
	.	Итератор хранит внутри себя ссылку на текущий элемент (на первый элемент при создании итератора) и имеет три метода:
	.	- hasNext() - возвращает true, если есть следующий элемент коллекции
	.	- next() - возвращает следующий элемент коллекции
	.	- remove() - удаляет текущий элемент коллекции
	.	По сути, итератор аналогичен оператору foreach.
	.	
	.	Также есть ListIterator. Он имеет дополнительные методы:
	.	- add(item)
	.	- set(item)
	.	- previous()
	.	- previousIndex()
	
	19) Перечислите основные категории исключительных ситуаций
	
	Базовый интерфейс Throwable. От него наследуются:
	.	1) Exception - исключение
	.	1.1) RuntimeException extends Exception - исключение времени выполнения (например, IndexOutOfBoundException)
	.	2) Error - ошибка (например, OutOfMemoryError)

	20) Какая разница между throw и throws?
	
	1) throws - декларация того, что внутри метода может произойти исключение = передача обработки этого исключения вышестоящему методу.
	.	public void method() throws SomeException {
	.	}
	.	public void method2() {
	.	try {
	.	method();
	.	} catch (SomeException e) {
	.	// обработать исключение
	.	}
	.	Либо можно передать обработку исключения еще выше.
	.	
	.	2) throw  - выбрасывает новое исключение, создавая объект класса, описывающего это исключение.
	.	Используется в так называемых обертках исключений - когда при вбрасывании исключения выполняется некая логика, затем это исключение вбрасывается снова с целью передать его вышестоящему методу.
	.	Либо вбрасывается другое исключение.
	.	
	.	public void method() throws AnotherException {
	.	  try {..}
	.	  catch(SomeException e) {
	.	  // some logic
	.	  throw new AnotherException();
	.	}
	.	
	.	} public void method2() {
	.	  try {
	.	    method();
	.	  }
	.	  catch (AnotherException e) {
	.	    // some logic
	.	  }
	.	}
	.	
	.	Либо можно просто выбросить нужное исключение в нужном месте программы.
	.	Смысл есть только во вбрасывании исключений для передачи их вышестоящим методам.
	.	Не нужно вбрасывать исключение и тут же его обрабатывать, так как это ресурсоемкая операция. Нужно использовать обычный if() в таком случае
	
	21) Зачем нужен блок finally?
	
	Используется при обработке исключений после блоков try и catch.
	.	Все, что находится внутри блока finally, будет выполнено в любом случае:
	.	- если исключение внутри блока try не произойдет
	.	- если исключение внутри блока try произойдет, но будет обработано в блоке catch
	.	- если сработает исключение, которое не может быть обработано внутри catch
	.	Обычно в этом блоке происходит освобождение ресурсов (закрытие файла, сокета, потока ввода-вывода и т.д.).
	.	Например:
	.	try {
	.	..
	.	} catch (SomeException ex) {
	.	..
	.	} finally {
	.	  connection.close();
	.	} 
	.	Если написать так:
	.	try {
	.	..
	.	} catch (SomeException ex) {
	.	..
	.	}
	.	connection.close();
	.	 То в случае некого AnotherException закрытия соединения не произойдет.
	.	
	.	Другой пример:
	.	try {
	.	  return 2;
	.	}
	.	finally {
	.	  return 1;
	.	} 
	.	В итоге метод вернет 1.
	
22) Что такое finalize?

Метод finalize есть у всех классов, так как он объявлен в классе Object, наследниками которого являются все классы в Java.
	.	Он вызывается при сборке мусора. В него можно поместить логику, которую нужно выполнить при уничтожении объекта соответствующего класса.
	.	Но использовать его не рекомендуется с точки зрения производительности и отсроченного выполнения (см. ответ на вопрос 2).
	
	23) Перечислите все виды внутренних классов
	
	1) Внутренний - имеет доступ к локальным полям и методам внешнего класса
	.	public class A {
	.	  public class b {
	.	  }
	.	}
	.	2) Внутренний статический - имеет доступ только к статическим полям и методам внешнего класса public class A {
	.	  public static class b {
	.	  }
	.	}
	.	3) Анонимный - используется однократно при создании объекта, для изменения поведения наследуемого класса “на месте”. Помогает сократить кол-во классов в проекте (если этот класс нигде больше не нужен).
	.	..
	.	List<String> list = new ArrayList<String>() {
	.	  @Override
	.	  public void add(String value) {
	.	  // собственная логика при добавлении элемента в список  
	.	  }
	.	};
	.	..
	.	4) Локальный - объявляется внутри метода
	.	..
	.	public void method() {
	.	  private LocalClass {
	.	    ..
	.	  }
	.	}
	.	..  
